#!/usr/bin/env python3

import argparse
import dns.query, dns.zone
import os.path
import socket
import sys
import traceback

from blessings import Terminal
from random import randint
from time import sleep

# TODO: 
__version__ = 'release-tbd'

def print_added(answer, color=False):
    # answer contains multiple records and does not end in newline
    answer = '+' + str(answer[0]).replace('\n', '\n+')

    if color:
        print(term.green + answer + term.normal)
    else:
        print(answer)

def print_removed(answer, color=False):
    # answer contains multiple records and does not end in newline
    answer =  '-' + str(answer[0]).replace('\n', '\n-')

    if color:
        print(term.red + answer + term.normal)
    else:
        print(answer)

def print_error(err_type, ns_name, rname, rdtype, color=False):
    if color:
        sys.stderr.write("%s@@ %s from %s for %s %s @@%s\n" %
                         (term.cyan, err_type, ns_name, rname, rdtype,
                          term.normal))
    else:
        sys.stderr.write("@@ %s from %s for %s %s @@\n" %
                         (err_type, ns_name, rname, rdtype))

def print_header(ns1_name, ns2_name):
    global seen_header

    if not seen_header:
        print("--- %s\n+++ %s" % (ns1_name, ns2_name))
        seen_header = True

def get_dns_response(query, ns_addr, ns_name, rname, rdtype):
    response = None
    successful = False
    t = 2

    while not successful:
        try:
            response = dns.query.udp(query, ns_addr, timeout=t)
            successful = True
        except dns.exception.Timeout:
            # Retry with backoff
            if t <= 8:
                t = t*2
                continue
            else:
                break

    return response

def main():
    progname = os.path.basename(sys.argv[0])
    parser = argparse.ArgumentParser(prog=progname)
    parser._optionals.title = "Options"

    parser.add_argument("-V", "--version", action="version",
                        version="%(prog)s: " + __version__)
    parser.add_argument("-c", "--color", dest="color_flag", action="store_true",
                        help="enable colorized output")
    parser.add_argument("-d", "--delay-max", dest="delay_max",
                        metavar='SECONDS',
                        help="maximum number of seconds of delay to introduce" +
                             " between each request")
    '''
    TODO: exclusions
    parser.add_argument("-n", "--ignore-ns", action="store_true",
                        help="Ignore changes to NS records at the apex")
    parser.add_argument("-s", "--ignore-soa", action="store_true",
                        help="Ignore changes to SOA records")
    parser.add_argument("-t", "--ignore-ttl", action="store_true",
                        help="Ignore changes to TTL values")
    '''
    parser.add_argument("-f", "--zonefile", dest="filename", required=True,
                        help="FILENAME is expected to be a valid zone master" +
                             " file\n" +
                             "https://tools.ietf.org/html/rfc1035#section-5")
    parser.add_argument("--from-ns", dest="ns1_name", required=True,
                        metavar="NAMESERVER1",
                        help="compare responses to NAMESERVER2")
    parser.add_argument("--to-ns", dest="ns2_name", required=True,
                        metavar="NAMESERVER2",
                        help="compare responses to NAMESERVER1")

    args = parser.parse_args()

    if args.color_flag:
        global term
        term = Terminal()

    try:
       zone = dns.zone.from_file(args.filename, allow_include=False,
                                 relativize=False)

    except dns.exception.DNSException:
        sys.stderr.write(progname + ": Unable to import %s.\n\n" % args.filename)
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)

    # TODO: IPv6 support with socket.getaddrinfo()
    ns1_addr = socket.gethostbyname(args.ns1_name)
    ns2_addr = socket.gethostbyname(args.ns2_name)

    global seen_header
    seen_header = False

    for (rname, rdataset) in zone.iterate_rdatasets():
        rdtype = dns.rdatatype.to_text(rdataset.rdtype)
        query = dns.message.make_query(rname, rdtype)

        r1 = get_dns_response(query, ns1_addr, args.ns1_name, rname, rdtype)
        if not r1:
            error("SERVFAIL", args.ns1_name, rname, rdtype, color=color_flag)
            continue

        r2 = get_dns_response(query, ns2_addr, args.ns2_name, rname, rdtype)
        if not r2:
            error("SERVFAIL", args.ns2_name, rname, rdtype, color=color_flag)
            continue

        # To help evade rate limits
        if args.delay_max:
            sleep(randint(0, args.delay_max))

        # .answer is an empty list if NXDOMAIN
        if r1.answer and r2.answer:
            # Answers from both servers, now compare records
            # XXX: Fix accuracy of response
            if r1.answer[0] != r2.answer[0]:
                print_header(args.ns1_name, args.ns2_name)
                print_removed(r1.answer, color=args.color_flag)
                print_added(r2.answer, color=args.color_flag)
        elif r1.answer and not r2.answer:
            # exists in r1 but NXDOMAIN in r2
            print_header(args.ns1_name, args.ns2_name)
            print_removed(r1.answer, color=args.color_flag)
        elif r2.answer and not r1.answer:
            # exists in r2 but NXDOMAIN in r1
            print_header(args.ns1_name, args.ns2_name)
            print_added(r2.answer, color=args.color_flag)
        else:
            # exists in zonefile but NXDOMAIN on both servers
            print_header(args.ns1_name, args.ns2_name)
            print_removed(r1.answer, color=args.color_flag)
            print_removed(r2.answer, color=args.color_flag)

if __name__ == '__main__':
    main()
